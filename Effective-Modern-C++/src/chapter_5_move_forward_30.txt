/**
   5 章 右辺値参照、ムーブセマンティクス、完全転送
   
   項目 30 ：完全転送できない場面を把握する

   重要ポイント
   - テンプレートの型推論がエラーになった場合、または誤った型を推論した場合、完全転送はエラーとなる。
   - 完全転送のエラー原因となる実引数には、波括弧による初期化子、ヌルポインタとして用いた 0 や NULL、宣言のみの const static な汎整数メンバ変数、
     テンプレート名、オーバーロード関数名、ビットフィールドがある。
*/

  C++11の箱を飾る最高の紋章に完全転送があります。『完全転送』です。そう、パーフェクトなんです！

そこにあるのは、「理想の完全」と「現実の完全」です。C++11 の完全転送は非常に優れたものですが、真の完全転送を実現できるのあは、詳細を
隅々まで見渡そうとした場合に限られます。本項目は読者を細部にまで慣れ親しませることを目的としています。
  『完全転送』とは単にオブジェクトを転送するだけでなく、オブジェクトの性質も転送します。オブジェクトの型、左辺値か右辺値か、const や
volatile かなどです。渡された実引数が左辺値か右辺値かを表す情報を埋め込むのは転送参照仮引数のみである以上、参照仮引数として処理する点
と併せて考えると、採用するのは転送参照になります。

template <class T>
void fwd(T&& param) {                   // どんな実引数でも受け取る
    f(std::forward<T>(param));          // f へ転送
}

転送関数は、その本来の性質として、一般化されます。例えば、上例のテンプレート fwd は任意の型の実引数をとり、どんなものでも転送します。
この汎用性を論理的に拡張すれば、転送関数単なるテンプレートではなく『可変長』テンプレートとし、個数も任意な実引数を受け取るべきです。
先の fwd を可変長対応すると次のようになります。

template <class... Ts>
void fwd(Ts&&... params) {              // 任意の実引数をとる
    f(std::forward<Ts>(params)...);     // f へ転送
}

上例は標準コンテナの直接配置関数でも採用している形態です。他にもスマートポインタ factory 関数、std::make_shred、std::make_unique が
あります。上例の目的関数 f と転送関数 fwd では、同じ実引数に対する両者の動作が異なると、『完全転送できません』

『波括弧による初期化』

『ヌルポインタとしての 0 や NULL』

『宣言のみの static const な汎整数メンバ変数』

『オーバーロードした関数名とテンプレート名』

『ビットフィールド』

『結論』
  完全転送は、ほとんどの場合では宣伝文句通りに動作します。注意しなければならない場合は僅かです。しかし、完全転送が問題となる場面、
すなわち一見問題なくみえるコードがコンパイルできない、またはコンパイルはできても期待とは違う動作となる場面では、完全転送の完全では
ない点の把握が重要となります。同様にその回避策も把握する必要がありますが、ほどんどの場合は直感的で分かりやすいものです。


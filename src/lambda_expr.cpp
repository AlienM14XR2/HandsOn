/**
ラムダ式（C++11）-----------------------------------------------------------

lambda expression

https://cpprefjp.github.io/lang/cpp11/lambda_expressions.html
「ラムダ式(lambda expressions)」は、簡易的な関数オブジェクトをその場で
 定義するための機能である。
 この機能によって、「高階関数(関数を引数もしくは戻り値とする関数)」を
 より使いやすくできる。そして...
```
 auto plus = [](int a, int b) { return a + b; };
int result = plus(2, 3); // result == 5
```

流石、大先生は言うことが、うちのリファレンス先生とは違うのだよ。
うちの先生のはじめのことばは次のだもの。
「ラムダ式は、簡潔に関数オブジェクトを記述する機能です。以下のように記述します。」
そして...
```
[キャプチャ](仮引数リスト)->戻り値の型{ 複合分 }
```
はぁ？

プロブラマがほしい情報、サンプルとともにズバッと言ってくださる、大先生は
流石です。ここはうちのは、ほっときます。大先生に師事を仰ぐとしよう。



ラムダ、これは利用したことはあっても、中身をよく知らない。

気になったのは （C++20）から導入された、*this のキャプチャ。

*this をキャプチャすると、そのクラスのオブジェクトをコピーするので、寿命切れを
心配する必要がないとのこと。

これは、写経してみるか。

ジェネリックラムダ（C++14）だと

初期化キャプチャ（C++14）だと

ジェネリックラムダのテンプレート構文（C++20）なに？

一応、動きそうなものから、写経かな。
*/

#include <iostream>

using namespace std;

// this のキャプチャ
class X {
    int x_ = 1;
public:
    void foo() {
        auto f = [this] {
            // ラムダ式内で、Xクラスのメンバ変数やメンバ関数を参照する。
            // private メンバ関数も呼び出せる。ん？特別みたいな言い方だけど
            // クラススコープ内の話なのだから、別段、普通ではないのか。
            return x_ + bar();
        };
        // ここからオレのDebug
        int ret = f();
        cout << "ret 大先生の力をかりて、うちの先生のDEBUG ようやく確認できた。=== " << ret << endl;

    }
    // このメソッドはリファレンスにはないよ。
    int getx_() {
        return x_;
    }
private:
    int bar() const {
        return 3;
    }
};

struct F {
  auto operator()(int a, int b) const -> decltype(a + b)
  {
     return a + b;
  }
};
/**
ラムダ式によって自動的に定義される関数オブジェクトは、それぞれが
一意な型名を持ち、その型名をユーザーが知る方法はない。そのため、
ラムダ式によって定義された関数オブジェクトを変数に持つためには、
autoを使用して型推論するか、std::functionクラスの変数に保持するかの、
いずれかの方法をとることになる。

ラムダ式からその外側の変数を使用するには、「キャプチャ(capture)」という機能を
使用する。ラムダ式の先頭にある[ ]は「ラムダ導入子(lambda-introducer)」
と呼ばれ、どの変数をどのようにキャプチャするかを、
このラムダ導入子のなかで指定する。キャプチャの方式としては、
参照かコピーのいずれかを選択できる。
*/
void f()
{
  int x = 3;

  // この時点で見える自動変数を参照でキャプチャし、
  // 参照した変数xを書き換える
  auto f = [&] { x = 1; };

  // 個別にキャプチャ方法を指定する場合は、
  // 以下のように、&の次に変数名を指定する
  // auto f = [&x] { x = 1; };

  f(); // x == 1
  cout << "x is " << x << endl;
  // 流石、大先生、納得です。
}

void g()
{
  int x = 3;

  // この時点で見える自動変数をコピーでキャプチャし、
  // コピーした変数xをラムダ式内で使用する
  auto f = [=] { return x + 1; };

  // 個別にキャプチャ方法を指定する場合は、
  // 以下のように、変数名を指定する
  // auto f = [x] { return x + 1; };

  int result = f(); // result == 4
  cout << "result is " << result << endl;
  // 流石、大先生、納得です。
}

int main() {
    cout << "START ラムダ式（C++11）========================= " << endl;
    // これは、大先生のとこサンプルね。
    auto plus = [](int a, int b){ return a+b; };
    int result_first_imp = plus(2,5);
    cout << "result_first_imp is " << result_first_imp << endl;

    f();
    g();


    // うちの投げっぱなし先生のサンプルは動かして確認中ね。
    X x;
    x.foo();
    int ret = x.getx_();
    cout << "ret is " << ret << endl;

    cout << "========================== ラムダ式（C++11）END" << endl;
    return 0;
}
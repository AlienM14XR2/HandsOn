/**
 ムーブセマンティクス、これたぶん、C++ の基本文法で飛ばした可能性が高い、
 記憶力が悪いオレでも流石にピンとこなさ過ぎ。

 ここは、大先生から読んでいこうと思う。
 https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html

 ムーブセマンティクスはコピーコストの削減を主な目的としており、また所有権の移動を実現する。
 右辺値参照はムーブ元のオブジェクト（右辺値）を束縛するための言語機能である。

 右辺値（Rvalues）と左辺値（Lvalues）について
 誤解を恐れずに言えば、右辺値とは名前をもたない一時的なオブジェクトである。
 また、左辺値とは明示的に実態のある名前付きオブジェクトである。 

 右辺値参照は、右辺値のみを束縛する参照である。
 C++11からは、型Tに対して T& で宣言される参照型を左辺値参照と呼ぶのに対して、T&& で宣言される参照型を右辺値参照と呼ぶ。

 C++03までは、右辺値のみを扱う右辺値参照は存在せず、右辺値はconst左辺値参照 const T& に束縛するよう扱われていた。
 このconst左辺値参照では左辺値も束縛できるため、左辺値／右辺値の区別情報が失われてしまい、右辺値のみに対して特別な処理を記述することができなかった。 

 ```
 std::vector<int> v, vv;
 v = vv;                        // 代入式1
 v = std::vector<int>(100, 0);  // 代入式2
 ```
 上記コードはC++03では、代入式1,2ともに右辺は vector<int> const& 型に束縛される。
 代入処理の中では、右辺の値をコピーし、左辺の値と置き換えられる。
 しかし代入式2の右辺は一時オブジェクトであり、直後に破棄されるため、一時オブジェクトをコピーすることは無駄といえる。
 もし右辺値と左辺値を型を用いて区別できれば、右辺値の場合はコピーせず単に左辺と置き換えるといった処理が記述できる。 

 右辺値参照は、右辺値と左辺値を型として区別するために導入された。
 C++11 以降では、代入式2の右辺は右辺値参照 vector<int>&& に束縛されるため、代入演算子オーバーロードにより左辺値参照とは区別して処理される。
 また、代入式2で行われる処理のことを「ムーブ」と呼ぶ。 

 この機能が必要になった背景・経緯
 
 ムーブセマンティクスは、C++03でもNRVO（特定の文脈でのコンストラクタの省略）や、 C++11で非推奨となったstd::auto_ptrで実現されていた。
 しかし、NRVOがいつでも機能するわけではなかった。
 また、std::auto_ptrにはコピーと同じ文法でムーブしていることなど、問題が多かった。
 そのため、コピーと区別でき、統一的にムーブを表す文法が言語機能として必要とされた。

 あぁ、なんとなく理解はしたが、その使いみちが LargeClass で行っている、
 ムーブコンストラクタとムーブ代入演算子 以外、分からないな。

 直接、関係はないが。
 ```
    std::unique_ptr<int> p(new int(1));
 ```
 これも気になる。

 そして、これもまた道理だと思うが、C++ GoF が終わったら
 C 同様、標準関数の使い方を地道に実践してみるのもありだと思う。

 fin.
*/
#include <iostream>
#include <string>
#include <utility>
#include <memory>
#include <algorithm>

using namespace std;

template<class M, class D>
void (*ptr_lambda_debug)(M,D) = [](auto message, auto debug) -> void {
    cout << message << '\t' << debug << endl;
};

// ムーブセマンティクスの説明で利用します。
class LargeClass {
    char* ptr;
public:
    LargeClass() {
        ptr = new char[1000];
        // e.g. バッファに対して、時間のかかる書き込みを実行する。
    }
    // コピーコンストラクタ
    LargeClass(const LargeClass& own) {
        ptr = new char[1000];
        std::copy(own.ptr, own.ptr + 1000, ptr);
    }
    // ムーブコンストラクタ
    LargeClass(LargeClass&& r) {
        // ポインタの挿げ替え
        ptr = r.ptr;
        // 元のオブジェクトは nullptr に
        r.ptr = nullptr;
    }
    // ムーブ代入演算子
    LargeClass& operator=(LargeClass&& r) {
        // 既存バッファの破棄
        delete [] ptr;
        // ポインタの挿げ替え
        ptr = r.ptr;
        // 元のオブジェクトは nullptr に
        r.ptr = nullptr;
        return *this;
    }
    ~LargeClass(){
        delete [] ptr;
    }
};

// 右辺値参照と左辺値参照の挙動をまとめると以下のようになる
int main() {
    cout << "START Move Semantics ===============" << endl;
    int x = 0;
    // 左辺値参照
    int& lvalue_ref_1 = x;          // OK
    // int& lvalue_ref_2 = 0        // Error 右辺値を左辺値参照で束縛している。

    // 右辺値参照
    // int&& rvalue_ref_1 = x;      // Error 左辺値を右辺値参照で束縛している。
    int&& rvalue_ref_2 = 0;         // OK

    // const 左辺値参照
    // ここまで来てやっと気付いた、これはオレが一番最初にいいって思って
    // 極力使うようにしていたやつか：）一時変数も扱えるやつね。
    const int& const_lvalue_ref_1 = x;  // OK
    const int& const_lvalue_ref_2 = 0;  // OK const 左辺値参照は右辺値を束縛できる。

    /**
     右辺値参照で宣言された変数は右辺値ではなく、左辺値である。
     右辺値参照であるということと、右辺値であるということは全く違うことである。
    */
    // i の型は int&& である。
    // i は左辺値 = i は実体を持ち名前のあるオブジェクト
    int&& i = 1;

    // x は左辺値なので右辺値参照できない。
    // int&& j = i      // Error

    if(1) {
        /**
        ムーブ

        ムーブとはあるオブジェクトから他のオブジェクトにリソースを明け渡すということである。
        値のコピーではコストが高くつく場合は、より高速に値を別の変数へ移すことができる。
        リソース明け渡し後のオブジェクトには何が入っているのか不明となり、値を参照した時の動作は対象オブジェクトの型に依存する。 後述する所有権の移動を除けば、
        一般にはムーブ後オブジェクトの状態は明確に規定されない事が多い。 

        あるオブジェクトをムーブしたいときには、 std::move()関数を利用する。 ムーブされた変数は右辺値となり、それ以降使える保証はなくなる。
        注意すべきことはstd::move()関数の呼び出しは
        「このオブジェクトはこれ以降使わないので好きに書き換えて良い」
        という明示にすぎない。
        実際のムーブは変数をstd::move()関数に通し、後述するムーブコンストラクタ・ムーブ代入演算子に渡した際に行われる。
        */
        std::string x = "Hello World.";
        // 何も起こらない。（warning は出るね。
        // std::move(x);

        // 実際に x から y へ文字列がムーブされる。
        std::string y = std::move(x);
    }
    if(2) {
        /**所有権の移動

        クラスによってはコピーは禁止されるが、ムーブならば可能ということがある。
        そういったクラスではムーブが所有権の移動を表す。
        同じものが複数存在してはいけないという制約を持つクラスが所有権の移動に対応しており、ムーブ後の変数は無効値（例えばスマートポインタならnullptr）となることが保証される。
        例を挙げると、std::unique_ptrがそれに当たる。 std::unique_ptrはあるオブジェクトの唯一の所有権を持つことを表すスマートポインタである。 所有権は唯一であるので、コピーが禁止されている。 しかし、別の変数にムーブ代入することはできる。
        */
        std::unique_ptr<int> p(new int(1));
        
        // 所有権は q に移り、p は nullptr になる。
        std::unique_ptr<int> q = std::move(p);
        ptr_lambda_debug<const char*,const int&>("*q is ",*q);
        if( p == nullptr ) {
            cout << "p is null." << endl;
        }
        // 他には、<iostream>も所有権の移動に対応している。

        // ごめんなさい、おっ、unique_ptr ついポインタなのかと、以下はError になる。
        // unique_ptr 次はこれについて調べてみたいね。
        // delete q;
    }
    if(3) {
        /**
        ムーブセマンティクス
        
        ムーブセマンティクスが必要とされる場面として、コピーに高いコストがかかる場合をあげる。
        コピーコンストラクタ、コピー代入に高いコストがかかる以下のクラスで説明する。
        */
        LargeClass x{};
        // とても時間がかかる。
        LargeClass y(x);

        /**
        コピーには時間がかかる。
        コピーをポインタの挿げ替えにしてしまえば、定数時間で処理が終わる。
        そうすると元のオブジェクトが参照できなくなる。
        しかし、そうなっても良い場合がある。
        一時変数からオブジェクトを作る場合などである。 
        */
        LargeClass tmp{};
        LargeClass z(tmp);
        // これ以降 tmp は使わない。

        /**
        もう使わない変数とそうでない変数を区別する必要がある。
        そこで登場するのが右辺値と右辺値参照である。
        右辺値であるということが、変数をムーブしてもよいという意味となる。
        右辺値が渡された場合に、ポインタを挿げ替えるため、 右辺値参照を引数にするコンストラクタ・コピー代入演算子（ムーブ演算）を定義する。 
        */
    }
    if(4) {
        /**
        ムーブコンストラクタ・ムーブ代入演算子
        
        さきほどのlarge_classにムーブコンストラクタ（右辺値参照を引数とするコンストラクタ）を追加する。
        同様にムーブ代入演算子（右辺値参照を引数とする代入演算子）を追加する。 
        */

        // 左辺値に対してstd::move()を適用すると右辺値となり、ムーブコンストラクタが呼ばれる。 
        LargeClass tmp{};
        LargeClass y{};
        LargeClass x(std::move(tmp));
        y = std::move(x);

        /**
        標準ライブラリで提供されるクラスのほとんどは、このようなムーブコンストラクタを用意している（mutex、atomicなどを除く）。

        ムーブコンストラクタ・ムーブ代入演算子は
            クラスがコピー演算を宣言していない
            クラスがムーブ演算を宣言していない
            クラスがデストラクタを宣言していない
            
        の３つを満たす場合のみ自動生成される、特殊メンバ関数である。
        */ 
        // また、defaultを指定することができる。
        // e.g.
        /**
            class large_class {
            public:
                // ムーブ演算のデフォルト指定
                large_class(large_class&&) = default;
                large_class& operator=(large_class&&) = default;
            };
        */
    }
    if(5) {
        /**
        ユニヴァーサル参照
        「転送参照(Forwarding Reference)」
        
        関数テンプレートの型パラメータTや型推論プレースホルダautoに参照修飾子&&を
        つけて宣言したものはユニヴァーサル参照と呼ばれ、通常の右辺値参照とは異なる動作をする。 
        なお「ユニヴァーサル参照(Universal Reference)」はScott Mayers氏による解説由来の俗称であり、
        後にC++17仕様において「転送参照(Forwarding Reference)」という正式名称が与えられた。

        // e.g.  ユニヴァーサル参照
            template <typename T>
            void f(T&& x) {}

        */
    }
    if(6) {
        /**
        完全転送（Perfect Forwarding）

        ある関数が受け取ったパラメータを別の関数へそのまま渡したいとき、 右辺値は右辺値として、
        左辺値は左辺値として別の関数へ転送したいことがある（完全転送）。
        ユニヴァーサル参照を用いると、呼び出し元における右辺値／左辺値という情報が、
        受け取り側で右辺値参照／左辺値参照という型情報によって区別可能となる。
        しかし右辺値を右辺値参照で受け取った場合、その引数をそのまま使うと左辺値になるため
        再び右辺値へ変換する必要が生じる。 

        つまり左辺値参照の場合は左辺値として、右辺値参照の場合は右辺値に変換して渡す機能が必要となる。
        そのような機能として、std::forward()関数が用意されている。
        利用時には std::forward<T>(a) のように、テンプレートパラメータとしてユニヴァーサル参照宣言時の
        型パラメータ名を明示する必要がある。

        e.g. 完全転送（Perfect Forwarding）

        #include <utility>

        template <typename T> void g(T);

        template <typename T>
        void f(T&& a)
        {
            // 引数 a が左辺値参照の場合は 左辺値 に
            // 右辺値参照の場合は 右辺値 に変換してから
            // 別関数 g() の実引数として渡す。
            g( std::forward<T>(a) ) ;
            // 関数 g() は値型 T としてパラメータを取るため
            // 左辺値ではコピーが、右辺値ではムーブが行われる。
        }
        */
    }
    
    cout << "=============== Move Semantics END" << endl;
    return 0;
}
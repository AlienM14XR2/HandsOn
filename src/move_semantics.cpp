/**
 ムーブセマンティクス、これたぶん、C++ の基本文法で飛ばした可能性が高い、
 記憶力が悪いオレでも流石にピンとこなさ過ぎ。

 ここは、大先生から読んでいこうと思う。
 https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html

 ムーブセマンティクスはコピーコストの削減を主な目的としており、また所有権の移動を実現する。
 右辺値参照はムーブ元のオブジェクト（右辺値）を束縛するための言語機能である。

 右辺値（Rvalues）と左辺値（Lvalues）について
 誤解を恐れずに言えば、右辺値とは名前をもたない一時的なオブジェクトである。
 また、左辺値とは明示的に実態のある名前付きオブジェクトである。 

 右辺値参照は、右辺値のみを束縛する参照である。
 C++11からは、型Tに対して T& で宣言される参照型を左辺値参照と呼ぶのに対して、T&& で宣言される参照型を右辺値参照と呼ぶ。

 C++03までは、右辺値のみを扱う右辺値参照は存在せず、右辺値はconst左辺値参照 const T& に束縛するよう扱われていた。
 このconst左辺値参照では左辺値も束縛できるため、左辺値／右辺値の区別情報が失われてしまい、右辺値のみに対して特別な処理を記述することができなかった。 

 ```
 std::vector<int> v, vv;
 v = vv;                        // 代入式1
 v = std::vector<int>(100, 0);  // 代入式2
 ```
 上記コードはC++03では、代入式1,2ともに右辺は vector<int> const& 型に束縛される。
 代入処理の中では、右辺の値をコピーし、左辺の値と置き換えられる。
 しかし代入式2の右辺は一時オブジェクトであり、直後に破棄されるため、一時オブジェクトをコピーすることは無駄といえる。
 もし右辺値と左辺値を型を用いて区別できれば、右辺値の場合はコピーせず単に左辺と置き換えるといった処理が記述できる。 

 右辺値参照は、右辺値と左辺値を型として区別するために導入された。
 C++11 以降では、代入式2の右辺は右辺値参照 vector<int>&& に束縛されるため、代入演算子オーバーロードにより左辺値参照とは区別して処理される。
 また、代入式2で行われる処理のことを「ムーブ」と呼ぶ。 

*/
#include <iostream>
#include <string>
#include <utility>

using namespace std;

template<class M, class D>
void (*ptr_lambda_debug)(M,D) = [](auto message, auto debug) -> void {
    cout << message << '\t' << debug << endl;
};

// 右辺値参照と左辺値参照の挙動をまとめると以下のようになる
int main() {
    cout << "START Move Semantics ===============" << endl;
    int x = 0;
    // 左辺値参照
    int& lvalue_ref_1 = x;          // OK
    // int& lvalue_ref_2 = 0        // Error 右辺値を左辺値参照で束縛している。

    // 右辺値参照
    // int&& rvalue_ref_1 = x;      // Error 左辺値を右辺値参照で束縛している。
    int&& rvalue_ref_2 = 0;         // OK

    // const 左辺値参照
    // ここまで来てやっと気付いた、これはオレが一番最初にいいって思って
    // 極力使うようにしていたやつか：）一時変数も扱えるやつね。
    const int& const_lvalue_ref_1 = x;  // OK
    const int& const_lvalue_ref_2 = 0;  // OK const 左辺値参照は右辺値を束縛できる。

    /**
     右辺値参照で宣言された変数は右辺値ではなく、左辺値である。
     右辺値参照であるということと、右辺値であるということは全く違うことである。
    */
    // i の型は int&& である。
    // i は左辺値 = i は実体を持ち名前のあるオブジェクト
    int&& i = 1;

    // x は左辺値なので右辺値参照できない。
    // int&& j = i      // Error

    if(1) {
        /**
        ムーブ
        ムーブとはあるオブジェクトから他のオブジェクトにリソースを明け渡すということである。
        値のコピーではコストが高くつく場合は、より高速に値を別の変数へ移すことができる。
        リソース明け渡し後のオブジェクトには何が入っているのか不明となり、値を参照した時の動作は対象オブジェクトの型に依存する。 後述する所有権の移動を除けば、
        一般にはムーブ後オブジェクトの状態は明確に規定されない事が多い。 

        あるオブジェクトをムーブしたいときには、 std::move()関数を利用する。 ムーブされた変数は右辺値となり、それ以降使える保証はなくなる。
        注意すべきことはstd::move()関数の呼び出しは
        「このオブジェクトはこれ以降使わないので好きに書き換えて良い」
        という明示にすぎない。
        実際のムーブは変数をstd::move()関数に通し、後述するムーブコンストラクタ・ムーブ代入演算子に渡した際に行われる。
        */
        std::string x = "Hello World.";
        // 何も起こらない。（warning は出るね。
        // std::move(x);

        // 実際に x から y へ文字列がムーブされる。
        std::string y = std::move(x);

    }
    
    cout << "=============== Move Semantics END" << endl;
    return 0;
}